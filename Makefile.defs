SHELL := /usr/bin/env bash
.SHELLFLAGS := -eu -o pipefail -c

# 根文件目录
ROOT_DIR := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
# 相对路径
RELATIVE_DIR := $(shell echo $(realpath .) | sed "s;$(ROOT_DIR)[/]*;;")

# 版本号
VERSION = $(shell cat $(ROOT_DIR)/VERSION)
# 主版本号
VERSION_MAJOR = $(shell cat $(ROOT_DIR)/VERSION | cut -d. -f1)
# 次版本号
VERSION_MINOR = $(shell cat $(ROOT_DIR)/VERSION | cut -d. -f2)
# 补丁版本号
VERSION_PATCH = $(shell cat $(ROOT_DIR)/VERSION | cut -d. -f3 | cut -d - -f1)
# 版本说明
VERSION_IDENTIFIER = $(shell cat $(ROOT_DIR)/VERSION | cut -d - -f2)

## Go语言相关
# Go版本确保最新
# renovate: datasource=golang-version depName=go
GO_VERSION := 1.21.0
GOPATH ?= $(shell go env GOPATH)
GOROOT ?= $(shell go env GOROOT)
GOBIN ?= $(shell go env GOBIN)
GO_BUILD_FLAGS =
GO_TEST_FLAGS =
GO_CLEAN_FLAGS =
GO_BUILD_LDFLAGS =
GOARCH ?= $(shell go env GOARCH)
GOOS ?= $(shell go env GOOS)
# GOPATH必须存在
ifeq "$(GOPATH)" ""
  #$(error Please set the environment variable GOPATH before running `make`)
endif
ifeq "$(GOBIN)" ""
	GOBIN=${GOPATH}/bin
endif

#  安装工具
INSTALL = install

CONTAINER_ENGINE?=docker
DOCKER_FLAGS?=
DOCKER_BUILD_FLAGS?=

# use gsed if available, otherwise use sed.
# gsed is needed for MacOS to make in-place replacement work correctly.
SED ?= $(if $(shell command -v gsed),gsed,sed)

DOCKER_IMAGE_TAG?=latest

export KUBECTL ?= kubectl

#  swagger
SWAGGER_VERSION := v0.30.3
SWAGGER := $(CONTAINER_ENGINE) run -u $(shell id -u):$(shell id -g) --rm -v $(ROOT_DIR):$(ROOT_DIR) -w $(ROOT_DIR) --entrypoint swagger quay.io/goswagger/swagger:$(SWAGGER_VERSION)

# renovate: datasource=docker depName=golangci/golangci-lint
GOLANGCILINT_WANT_VERSION = v1.55.2
GOLANGCILINT_IMAGE_SHA = sha256:e699df940be1810b08ba6ec050bfc34cc1931027283b5a7f607fb6a67b503876
GOLANGCILINT_VERSION = $(shell golangci-lint version --format short 2>/dev/null)

GIT_VERSION = $(shell git show -s --format='format:%h %aI')

CODE_VERSION_DIR = /pkg/version.flattenVersion
FULL_BUILD_VERSION = $(VERSION) $(GIT_VERSION)
ROOT_GO_MODULE = $(shell go list -m)
GO_BUILD_LDFLAGS += -X "$(ROOT_GO_MODULE)$(CODE_VERSION_DIR)=$(FULL_BUILD_VERSION)"
ifeq ($(NOSTRIP),)
    # Note: these options will not remove annotations needed for stack
    # traces, so panic backtraces will still be readable.
    #
    # -w: Omit the DWARF symbol table.
    # -s: Omit the symbol table and debug information.
    GO_BUILD_LDFLAGS += -s -w
endif
GO_TEST_FLAGS += -vet=all
ifneq ($(GO_MOD_VENDOR),)
    GO_BUILD_FLAGS += -mod=vendor
GO_TEST_FLAGS += -mod=vendor -vet=all
GO_CLEAN_FLAGS += -mod=vendor
endif
GO_BUILD = CGO_ENABLED=0 go build
# Support CGO cross-compiling for amd64 and arm64 targets
CGO_CC =
CROSS_ARCH =
ifneq ($(GOARCH),$(NATIVE_ARCH))
    CROSS_ARCH = $(GOARCH)
endif
ifeq ($(CROSS_ARCH),arm64)
    CGO_CC = CC=aarch64-linux-gnu-gcc
else ifeq ($(CROSS_ARCH),amd64)
    CGO_CC = CC=x86_64-linux-gnu-gcc
endif
GO_BUILD_WITH_CGO = CGO_ENABLED=1 $(CGO_CC) go build
ifneq ($(RACE),)
    GO_BUILD_FLAGS += -race
    GO_TEST_FLAGS += -race
    GOTEST_COVER_OPTS += -covermode=atomic

    # GO_BUILD becomes GO_BUILD_WITH_CGO as `-race` requires CGO
    GO_BUILD = $(GO_BUILD_WITH_CGO)
    ifeq ($(LOCKDEBUG),)
        LOCKDEBUG=1
    endif
else
    GOTEST_COVER_OPTS += -covermode=count
endif

ifneq ($(LOCKDEBUG),)
    GO_TAGS_FLAGS += lockdebug
endif

GO_BUILD_FLAGS += -ldflags '$(GO_BUILD_LDFLAGS) $(EXTRA_GO_BUILD_LDFLAGS)' -tags=$(call join-with-comma,$(GO_TAGS_FLAGS)) $(EXTRA_GO_BUILD_FLAGS)
GO_TEST_FLAGS += -tags=$(call join-with-comma,$(GO_TAGS_FLAGS))

ifeq ($(NOOPT),1)
    GO_BUILD_FLAGS += -gcflags="all=-N -l"
endif

GO_BUILD += $(GO_BUILD_FLAGS)
GO_BUILD_WITH_CGO += $(GO_BUILD_FLAGS)

GO_TEST = CGO_ENABLED=0 go test $(GO_TEST_FLAGS)
GO_CLEAN = go clean $(GO_CLEAN_FLAGS)

GO_VET = go vet
GO_LIST = go list


##@ GoLint
golangci-lint: make_sure_go_workdir ## Run golangci-lint
ifneq (,$(findstring $(GOLANGCILINT_WANT_VERSION:v%=%),$(GOLANGCILINT_VERSION)))
	golangci-lint run $(GOLANGCI_LINT_ARGS)
else
	$(CONTAINER_ENGINE) run --rm -v `pwd`:/app -w /app docker.io/golangci/golangci-lint:$(GOLANGCILINT_WANT_VERSION)@$(GOLANGCILINT_IMAGE_SHA) golangci-lint run $(GOLANGCI_LINT_ARGS)
endif

golangci-lint-fix: make_sure_go_workdir ## Run golangci-lint to automatically fix warnings
	$(QUIET)$(MAKE) golangci-lint GOLANGCI_LINT_ARGS="--fix"

lint: golangci-lint

lint-fix: golangci-lint-fix

# 获取终端宽度
TERM_WIDTH := $(shell tput cols)
# 生成等宽的符号行
define print_line
	@echo $(shell printf '$(1)%.0s' $$(seq 1 $(TERM_WIDTH)))
endef

define print_help_line
  @printf "  \033[36m%-29s\033[0m %s.\n" $(1) $(2)
endef

define print_help_from_makefile
  @awk 'BEGIN {FS = ":.*##"; printf "\nUsage:\n  make \033[36m<target>\033[0m\n"} /^[a-zA-Z0-9][a-zA-Z0-9 _-]*:.*?##/ { split($$1, targets, " "); for (i in targets) { printf "  \033[36m%-28s\033[0m %s\n", targets[i], $$2 } } /^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0, 5) } ' $(MAKEFILE_LIST)
endef

make_sure_go_workdir: